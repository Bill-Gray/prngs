/* random4.cpp: lagged-Fibonacci random number generator.
Mostly of historical interest;  see comments below on why I'm
using Mersenne Twister or WELL algorithms now.

Copyright (C) 2010, Project Pluto

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301, USA.    */

/* A lagged Fibonacci generator,  wherein x[n]=x[n-1279]^[x-418].
This is fast,  easy to understand,  has a very long cycle,  and
probably isn't all that great a choice (I wrote it before I
realized that).  Lagged Fibonacci generators have some theoretical
deficiencies,  and there are perfectly good PRNGs out there
(Mersenne Twister,  WELL,  some of Geore Marsaglia's generators)
that aren't much more complicated,  have undergone much more
thorough testing,  and won't leave you wondering if your random
numbers are random enough.

   This works with an array of 1279 bits,  a.k.a. 20 64-bit ints
with an unused bit left over at the end.  The period is
2^1279-1,  i.e.,  long enough for all ordinary uses.

  There's a certain amount of magic here.  One could simply go
through a loop from 0 to 1279,  looking at the bit 418 places
ago (or 1279-418=861 bits "ahead") and,  if that bit is set,
flipping the current bit.  That's slow.  With some thought,  we
can flip an integer (32 or 64 bits) at a time.  See 'random4.z'
for details,  including the bit-at-a-time version used as a
check on the results.

  Some implementations would just use an array of 1279 integers.
But that seemed wasteful to me.  Or they'd just use a shorter
array and a recurrence such as x[n]=x[n-55]^[x-24].  But then
the cycle length is a lot shorter (2^55-1 for the lowest bit;
2^86-1 for the highest bit,  assuming 32-bit integers.)

  In what follows,  the 1279 bits are stored in twenty 64-bit
integers,  with one "padding" bit at the end.  This results
in a 64-bit generator,  with added functions to return this
split into halves for 32-bit pseudo-random numbers,  or to give
floats distributed from zero to 1.

  Seeding a lagged Fibonacci generator is apparently an inexact
science. I did it by going to a "HotBits" site,  which uses a
radioactive sample to generate random bits:

https://www.fourmilab.ch/hotbits/secure_generate.html

  I selected the 'hexadecimal output' option and arranged it
into the following array.           */

#include <stdint.h>

uint64_t random64( void)
{
   static int loc = 0;
   static uint64_t x[20] = {
        UINT64_C( 0xc7209ee0015a4555), UINT64_C( 0x00812d37806296ed),
        UINT64_C( 0xb6b5dff5184bf56a), UINT64_C( 0xd7ede5a5697c554c),
        UINT64_C( 0xbc37b1d154dd8352), UINT64_C( 0xde005da9f6e5c015),
        UINT64_C( 0x9b92e0c7df4c0ef8), UINT64_C( 0xeea24ea0274ef6e1),
        UINT64_C( 0x4d6cbb4ac26a38e3), UINT64_C( 0xb19e04f3d810c895),
        UINT64_C( 0xbcacf1771131cd16), UINT64_C( 0x77be2a92c05a4b24),
        UINT64_C( 0xa5523bc8bc563a25), UINT64_C( 0x159c1b16339d694c),
        UINT64_C( 0xf31dc36d995ed614), UINT64_C( 0x4c91763575f2c4f9),
        UINT64_C( 0x252e2962dae2ffff), UINT64_C( 0xd4f0a838f3041354),
        UINT64_C( 0xccc53d13e0f1387b), UINT64_C( 0x6ce213f01e42f9cb) };

   if( !loc)
      {
      int i;

      uint64_t *aptr = x, *eptr = x + 13;

      for( i = 6; i; i--)
         {
         *aptr ^= *eptr++ >> 29;
         *aptr++ ^= *eptr << 35;
         }
      *aptr++ ^= (*eptr >> 29) | (*x << 34);
      eptr = x;
      for( i = 13; i; i--)
         {
         *aptr ^= *eptr++ >> 30;
         *aptr++ ^= *eptr << 34;
         }
      x[19] &= UINT64_C(0x7fffffffffffffff);
      loc = 18;
      }
   else
      loc--;
   return( x[loc]);
}

   /* 32-bit random values should be enough for anybody.  They can */
   /* be generated by getting 64-bit random values and returning   */
   /* it in two 32-bit pieces.   */

uint32_t random32( void)
{
   static uint64_t r;
   static int state = 0;
   uint32_t rval;

   if( !state)
      {
      r = random64( );
      rval = (uint32_t)(r >> 32);
      state = 1;
      }
   else
      {
      rval = (uint32_t)r;
      state = 0;
      }
   return( rval);
}


/* One can take a 64-bit integer,  mask off the upper twelve bits, */
/* OR in a suitable constant,  and get the IEEE equivalent of a    */
/* floating-point value from 1 to 2.  Subtract 1 from it,  and     */
/* you can get uniform random numbers [0, 1).  A trick grabbed     */
/* from _Numerical Recipes in C_,  p. 285,  and updated from the   */
/* 32-bit world to the 64-bit one.                                 */
/*   The authors of _NR_ note that this is a really dirty trick,   */
/* highly machine-dependent.  It'll break on a non-IEEE machine.   */
/* But I don't know if those are even made anymore.                */
/*   I thought this trick might not help much with modern floating */
/* point hardware,  but gave it a try (using the commented-out     */
/* line below) and found the trick makes a slight but noticeable   */
/* speed improvement.                                              */

double drandom( void)
{
   const uint64_t jflone = UINT64_C( 0x3ff0000000000000);
   const uint64_t jflmsk = UINT64_C( 0x000fffffffffffff);
   const uint64_t rval = jflone | (jflmsk & random64( ));

   return( *((double *)&rval) - 1.);
// return( (double)random64( ) * (.5 / (double)two_to_63));
}

#ifdef TEST_PROGRAM

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main( const int argc, const char **argv)
{
   int i;
   int delays = (argc == 1 ? 0 : atoi( argv[1]));

   while( delays--)
      random32( );
   printf( "%.2lf seconds elapsed\n",
                  (double)clock( ) / (double)CLOCKS_PER_SEC);
   for( i = 0; i < 320; i++)
      printf( "%08x%s", random32( ),
                       (i % 8 == 7 ? "\n" : " "));
   return( 0);
}
#endif


#ifdef TEST_DBL

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

int main( const int argc, const char **argv)
{
   int n = atoi( argv[1]), i, count = 0;
   clock_t t0 = clock( );
   double dt;

   for( i = n; i; i--)
      {
      const double x = drandom( );
      const double y = drandom( );

      if( x * x + y * y < 1.)
         count++;
      }
   dt = (double)(clock( ) - t0) / (double)CLOCKS_PER_SEC;
   printf( "%.3lf seconds;  %lf/second\n",
            dt, (double)n / dt);
   printf( "pi = %lf +/- %lf\n", 4. * (double)count / (double)n,
            4. * sqrt((double)count) / (double)n);
   return( 0);
}
#endif
